# go语言编程

## 第2章 
### 顺序编程
1. 变量 
    1. 变量声明
        - 变量声明1
        ```
            var v1 int
            var v2 string
            var v3 [10]int
            var v4 []int
            var v5 struct {
                f int
            }
            var v6 *int
            var v7 map[string]int
            var v8 func(a int) int
        ```
        - 变量声明2
        ```
        var (
            v1 int
            v2 string    
        )
        ```
   1. 变量初始化
        ```
            var v1 int = 10
            var v2 = 10 // 编译器可以自动推导出v2的类型
            v3 := 10   // 编译器可以自动推导出v3类型
            注意： 除了第三种声明方式不能用于声明全局变量
        ```
    1. 变量赋值
      - 变量初始化和变量赋值是两个不同的概念
      - 多重赋值
        ```
            i, j = j, i
        ```
    1. 匿名变量
        ```
            _, _, nick := GetName()
        ```
1. 常量 
   ```
    在Go语言中，常量是指编译期间就已知且不可改变的值。常量可以是数值类型（包括整数、浮点数和复数类型）、布尔类型、字符串类型等。
   
   字面常量是无类型常量 
   ```
    1. 字面常量
        `
        所谓字面常量（literal),是指程序中硬编码的常量
        `
        ```
            -12                 // 无类型的 它可以赋值给int、uint、 int32、 int64、 float32、 float64、 complex64、complex128等类型的变量
            3.1415926           // 浮点型的常量
            3.2 + 12i           // 复数类型的常量
            true                // 布尔类型的常量
            "foo"               // 字符串常量
        ```
    1. 常量定义
        `通过const关键字，你可以给字面常量指定一个友好的名字`  
        ```
            const Pi float64 = 3.1415926
            const zero = 0.0                // 无类型浮点常量
            const (
                size int64 = 1024
                eof = -1                    // 无类型整形常量
            )
            const u, v float32 = 0, 3       // u = 0.0, v = 3.0, 常量的多重赋值
            const a, b, c = 3, 4, "foo"     // a = 3, b = 4, c = "foo", 无类型整数和字符串常量 
        ```
        `常量定义的右值也可以是一个在编译期运算的常量表达式，比如`
        ```
            const mask = 1 << 3
            // 由于常量的赋值是一个在编译期行为，所以右值不能出现在任何需要运行期才能得出结果的表达式。
            const Home = os.GetEnv("HOME")
        ```    
    1. 与定义常量
        ```
            // Go 语言预定义了这些常量： true、false、iota
            // iota比较特殊，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次itoa，其所代表的数字会自增1。
            const (                 // iota 被重设为 0
                c0 = iota           // c0 == 0
                c1 = iota           // c1 == 1
                c2 = iota           // c2 == 2
            )
      
            const (
                a = 1 << iota       // a == 1 (iota 在每一个const开头被重设为0)
                b = 1 << iota       // b == 2
                c = 1 << iota       // v == 4
            )
      
            const (
                u           = iota * 42     // u == 0
                v float64   = iota * 42     // v == 42.0
                w           = iota * 42     // w == 84
            )
        
            const x = iota          // x == 0 (因为iota又被重设为0了)
            const y - iota          // y == 0 (同上)
      
            const (
                c0 = iota           // iota被重设为0
                c1                  // c1 == 1
                c2                  // c2 == 2
            )
      
            const (
                a = 1 << iota       // a ==1 (iota 在每个const开头被重设为0)
                b                   // b == 2
                c                   // c == 4
            )
        ```
    1. 枚举
        ```
            枚举指一系列相关的常量，Go语言并不支持众多其他语言支持的enum关键字
            const (
                SUNDAY = iota
                Monday
                Tuesday
                Wednesday
                Thursday
                Friday
                Saturday
                numberOfDays        // 这个常量没有导出
            )
            注意：同Go语言的其他符号(symbol)一样，以大写字母开头的常量在包外可见
        ```  
1. 类型
    ```
        基础类型
            - 布尔类型      bool
            - 整形         int8、byte、int16、int、uint、uintptr等
            - 浮点类型      float32、float64
            - 复数类型      complex64、complex128
            - 字符串        string
            - 字符类型      rune
            - 错误类型      error
        复合类型
            - 指针         pointer
            - 数组         array
            - 切片         slice
            - 字典         map
            - 通道         chan
            - 结构体        struct
            - 接口         interface
            
        注意： 这几种基础类型： int、uint、uintptr,使用在不能对这些类型做任何假设,对于常规开发来说，用int和uint就可以了，没必要用int8之类明确指定的类型，以免导致一移植困难。
   ```   
   1. 布尔类型
        ```
        var v1 bool
        v1 = true 
        v1 = bool(1) // 编译错误
        v1 = (1 != 0) // 编译正确
        布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。
      ```
   1. 整形
        ```
         类型                     长度                 值范围 
            int8                    1                   -128 ~ 127
            uint8(即byte)           1                   0 ~ 256
            int16                   2                   -32768 ～ 32767
            uint16                  2                   0 ~ 655535
            int32                   4                   -2147483648 ~ 2147483647
            uint32                  4                   0 ~ 4294967295
            int64                   8                   -9223372036854775808 ~ 9223372036854775807
            uint64                  8                   0 ~ 18 446 744 074 709 551 615
            int                     平台相关             平台相关
            uint                    平台相关             平台相关
            uintptr                 同指针               在32位平台下为4字节，64位平台下为8字节   
      ```
      1. 类型表示
        ```
        需要注意的是： int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换，比如以下的列子会有编译错误：
            var value2 int32
            value1 := 64    // value1 将会被自动推导为int类型
            value2 = value1 // 编译错误
        使用强制类型转化可以解决这个编译错误：
            value2 = int32(value1)  // 编译通过
      ```
      1. 数值运算
        ```
        Go语言支持下面的常规整数运算： +, -, *, %. %和在C语言中一样是求余运算
      ```
      1. 比较运算
        ```
        Go语言支持以下的几种比较运算符： >, <, ==, <= 和 ！= 。 这一点与大多数其他语言相同，与c语言完全一致。
        
        两个不同类型的整数不能直接比较， 比如int8类型的数和int类型的数不能直接比较，但各种类型的整数变量都可以直接与字面常量进行比较。
      ```
      1. 位运算
        ```
            运算                       含义                          样例
            x << y                      左移                          124 << 2    // 结果为496
            x >> y                      右移                          124 >> 2    // 结果为32
            x ^ y                       异或                          124 ^ 2     // 结果为126
            x & y                       与                            124 & 2    // 结果为0
            x | y                       或                            124 | 2    // 结果为126
            ^x                          取反                          ^2          // 结果为-3
        Go语言的大多数位运算符与C语言都比较类似，除了取反在C语言中是~x，而在Go语言中是^x。
      ```
   1. 浮点型
      1. 浮点数表示
        ```
        Go语言定义了两个类型float32和float64,其中float32等价于C语言的float类型，float64等价于C语言的double类型。
            var fvalue1 float32
            fvalue1 = 12
            fvalue2 := 12.0     // 如果不加小数点，fvalue2会被推导为整数而不是浮点数。 ffvalue2 type is float64
            
            fvalue1 = fvalue2   // 编译错误，必须使用强制类型转换
      ```
      1. 浮点数比较
        ```
        因为浮点数不是一种精确的表示方式，所以像整型那样直接用==来判断两个浮点数是否相等是不可行的，这可能会导致不稳定的结果
            下面是一种推荐的替代方案：
                import “math”
                
                func IsEqual(f1, f2, p float64) bool {
                    return math.Abs(f1-f2) < p
                }
      ```
   1. 复数类型
        ```
        复数实际上由两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示虚部（imag).
      ```
      1. 复数表示
        ```
        var value1 complex64        // 由2个float32构成的复数类型
        valuel = 3.2 + 12i
        value2 := 3.2 + 12i         // value2是complex128类型
        value3 := complex(3.2, 12   // value3结果同value2
      ```
      1. 实部与虚部
        ```
        对于一个复数z = complex(x, y), 就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x,通过imag(z)获得该复数的虚部，也就是y。
      ```
   1. 字符串
      ```
        在Go语言中，字符串也是一种基本类型。相比之下，C/C++语言中比不存在原生的字符串类型，通常使用字符数组来表示，并以字符指针来传递。
        Go语言中字符串的声明和初始化非常简单，比如：
            var str string          // 声明一个字符串变量
            str = "Hello world"     // 字符串赋值
            ch := str[0]            // 取字符串的第一个字符， ch 类型是byte 
      ```     
      ```
        字符串的内容可以用类似于数组下标的方式获取,但与数组不同，字符串的内容不能在初始化后被修改，比如以下的例子：
            str := "Hello world"        // 字符串也支持声明时进行初始化的做法
            str[0] = 'x'                // 编译错误
      ```
   1. 字符类型
        ```
        在Go语言中支持两个字符类型，一个是byte（实际上是uint8的别名），代表UTF-8字符串的单个字节的值；另一个是rune,代表单个Unicode字符。
      尽管unicode字符在标准库中有支持，但实际上较少使用。      
      ```
   1. 数组
        ```
        数组是Go语言编成中最常用的数据结构之一。顾名思义，数组就是指一系列同一类型数据的集合。数组中包含的每一个数据被称为数据元素（element），一个数组包含的元素个数被称为数组的长度。
        以下为一些常规的数组声明方法：
        [32]byte                    // 长度为32的数组，每个元素为一个字节
        [2*N]struct {x, y int32}    // 复杂类型数组
        [1000]*float64              // 指针数组
        [3][5]int                   // 二维数组
        [2][2][2]float64            // 三维数组 等同于[2][2]([2]float64)
        在Go语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量表达式(常量表达式是指在编译期即可计算结果的表达式).
        数组的长度是该数组类型的一个内置常量，可以用Go语言的内置函数len()来获取。
      ```
      1. 元素访问
        ```
        可以使用数组下标来访问数组中的元素。与C语言相同，数组下标从0开始。len(array)-1 则表示最后一个元素的下标。
       Go语言还提供了一个关键字range,用于便捷地遍历容器中的元素。当然，数组也是range的支持范围。
       ```
      1. 值类型
        ```
        需要特别注意的是，在Go语言中数组是一个值类型（value type),所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。
       ```
   1. 数组切片       
        ```
        初看起来，数组切片就像一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量
            - 一个指向原生数组的指针
            - 数组切片中的元素个数
            - 数组切片已分配的存储空间
      ```
      1. 创建数组切片
        - 基于数组
            ```
           var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
           var mySlic []int = myArray[:5]
           mySlic = myArray[:]
           mySlic = myArray[5:]
          ```
        - 直接创建
            ```
            Go语言提供的内置函数make()可以用于灵活地创建数组切片
                mySlic1 := make([]int, 5)       // 5个元素，元素初始化为0
                mySlic2 := make([]int, 5, 10)   // 5个元素，元素初始化为0，并预留10个元素的存储空间
                mySlic3 := []int{1, 2, 3, 4, 5} // 直接创建并初始化包含5个元素的数组切片
          ```
      1. 元素遍历
        ```
        操作数组元素的所有方法都适合用于数组切片，比如数组切片也可以按下标读写元素，用len()函数获取元素个数，并支持使用range关键字来快速遍历所有元素。
      ```
      1. 动态增减元素
        ```
        mySlic := make([]int, 5, 10)
        mySlic := append(mySlic, 1, 2, 3) // 生成一个新的切片数组
        函数append()的第二个参数其实是一个不定参数，我们可以按自己需求添加若干个元素。甚至直接将一个数组切片追加到另一个数组切片的末尾。
        mySlic2 := []int{8, 9, 10}
        mySlic = append(mySplice, mySlice2...)
      ```
      1. 基于数组切片创建数组切片
        ```
        类似于数组切片可以基于一个数组创建，数组切片也可以基于另一个数组切片创建。
        oldSlice := []int{1, 2, 3, 4, 5}
        newSlice := oldSlice[:3]    // 基于oldSlice的前三个元素创建新数组切片
        注意： 选择的oldSlice元素范围甚至可以超过所包含的元素个数，比如newSlice可以基于oldSlice的前6个元素创建，虽然oldSlice只包含5个元素。只要这个选择的范围不超过pldSlice的存储能力（即cap()返回的值），
      那么这个创建程序就是合法的，newSlice中超出oldSlice元素的部分都会填上0.
      ```
      1. 内容复制
        ```
        数组切片支持Go语言的另一个内置函数copy(), 用于将内容从一个数组切片复制到另一个数组切片，如果加入的两个数组切片不一样大，
      就会按其中较小的那个数组切片的元素个数进行复制。
      ```
   1. map
      ```
        map是一堆键值对的未排序集合
      ```
      1. 变量声明
        ```
        map的声明基本上没有多余的元素,比如：
        var myMap map[string]int
      ```
      1. 创建
        ```
        我们可以使用Go语言内置的函数make()来创建一个新的map。
        myMap := make(map[string]int, 100)
        创建并初始化map的代码如下:
        myMap = map[string]int {
            "123":1, 
            "456":2,
        }
      ```
      1. 元素u赋值
        ```
        myMap["123"] = 2
      ```
      1. 元素删除
        ```
        Go语言提供了一个内置函数delete()，用于删除容器内的元素。
        delete(myMap, "123")
        上面的代码将从myMap中删除键为"123"的键值对。如果"123"这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。
        ```
        在Go语言中，map的查找功能设计得比较精巧。
        value, ok := myMap["123"]
        if ok {
            // 找到了
        }
      ```
1. 流程控制
    ```
   - 程序设计语言的流程控制语句,用于设定计算机执行的次序,建立程序的逻辑结构.可以说,流程控制语句是整个程序的骨架.
   - 流程控制语句一般起以下3个作用:
        1. 选择, 即根据条件跳转到不同的执行序列;
        2. 循环, 即根据条件反复执行某个序列,当然每一次循环执行的输入输出可能会发生变化;
        3. 跳转, 即根据条件返回到某执行序列;
   - Go语言支持如下的几种流程控制语句:
        1. 条件语句, 对应的关键字为 if, else, else if;
        2. 选择语句, 对应的关键字为 switch,case,和select;
        3. 循环语句, 对应的关键字为for和range;
        4. 跳转语句, 对应的关键字为goto;
        5. 为了满足更丰富的控制需求,Go语言还添加了如下关键字:
            - break, continue, fallthrough
   ```       
   1. 条件语句
        ```
        if a < 5 {
            return 0
        } else {
            return 1
        }
       关于条件语句,需要注意以下几点:
            - 条件语句不需要使用括号i将条件包含起来();
            - 无论语句体内有几条语句,花括号{}都是必须存在的;
            - 左花括号{必须与if或者else处于同一处;
            - 在if之后,条件语句之前,可以添加变量初始化语句,使用;间隔;
            - 在有返回值的函数中,不允许将"最终的"return语句包含在if...else...结构中,否则会编译失败;
                func example(x int) int {
                    if x == 0 {
                        return 5
                    } else {
                        return x
                    }
                }
       ```     
   1. 选择语句
        ```
        根据传入条件的不同,选择语句会执行不同的语句.
            switch i {
                case 0:
                    fmt.Printf("0")
                case 1:
                    fmt.Printf("1")
                case 2:
                    fmt.Printf("2")
                default:
                    fmt.Printf("default")
            }
        比较有意思的是,switch后面的表达式甚至不是必需的,比如下面的例子;
            switch {
                case 0 <= Num && NUm <= 3:
                    fmt.Printf("0-3")
                case 4 <= Num && Num <= 6:
                    fmt.Printf("4-6")
                case 7 <= Num && Num <= 9:
                    fmt.Printf("7-9")      
            }
        在使用switch结构🥌时,我们需要注意以下几点;
            - 左花括号{必须与switch处于同一行;
            - 条件表达式不限制为常量或整数;
            - 单个case中,可以出现多个结果选项;
            - 与C语言等规则相反,Go语言不需要用break来明确退出一个case;
            - 只有在case中明确添加fallthrough关键字,才会继续执行紧跟的下一个case;
            - 可以不设定switch之后的条件表达式,在此种情况下,整个switch结构与多个if...else...的逻辑作用等同.
      ```  
   1. 循环语句
        ```
        Go语言中的循环语句只支持for关键字,而不支持while和do-while结构.关键字for的基本使用方法与C和C++中非常接近:
            sum := 0
            for i := 0; i < 10; i++ {
                sum += i
            }
        让开发者不用写无聊的for(;;){}
            for{
                sum++
                if sum > 100 {
                    break
                }
            }
        在条件表达式中也支持多重赋值,如下所示;
            a := []int{1,2,3,4,5,6}
            for i, j := 0, len(a) - 1; i < j; i, j = i + 1, j - 1 {
                a[i], a[j] = a[j], a[i]
            }
      
        使用循环语句是,需要注意的有以下几点.
            - 左括号{必须与for处于同一行;
            - Go语言中的for循环与C语言一样,都允许在循环条件中定义和初始化变量,唯一的区别是,Go语言不支持以逗号为i间隔的多个赋值语句,必须使用平行赋值的方式来初始化多个变量.
            - Go语言的for循环同样支持continue和break来控制循环,但是它提供了一个更高级的break,可以选择中断哪一个循环,如下例:
                JLoop:
                    // 标签和break之间不可以存在代码
                    // 此处不能有代码(我测试后的结果)
                    for j := 0; j < 5; j++ {
                        for i = 0; i < 10; i++ {
                            if i > 5 {
                                break JLoop // 终止(中断)的是JLoop标签处的外层循环
                                // JLoop 标签不能出现在break之后
                            }
                        }
                    }
      ```
   1. 跳转语句
        ```
        跳转到本函数内的某个标签
            func myfunc() {
                i := 0
                HERE:
                    // 标签和goto之间可以存在代码
                    fmt.println(i)
                    i++
                    if i < 10 {
                        goto HERE
                        // HERE 标签可以出现在本函数任何地方
                    }
            }
      ```
1. 函数
    ```
    函数构成代码执行的逻辑结构,在Go语言中,函数的基本组成为: 关键字func,函数名,参数列表,返回值,函数体和返回语句.
   ```  
   1. 函数定义
    ```
    func Add(a int, b int) (ret int, err error) {
        if a < 0 || b << 0 {
            err = error.New("error")
            return 
        }
        return a + b, nil
   }
   如果参数列表中若干个相邻的参数类型相同,比如上面例子中的a和b,则可以在参数列表中省略前面变量的类型声明.
    func Add(a, b int)(ret int, err error) {
        // ...
    }
   如果返回值列表中多个返回值的类型相同,也可以用同样的方式合并.
   如果函数只有一个返回值,也可以这么写:
    func Add(a, bint) int {
    }
   ```
   1.函数调用
   ```
    Go语言中的函数名的大小写不仅仅是风格,更是直接体现了该函数的可见性,这一点尤其需要注意.
   比如写成add_xxx这样的Linux风格,Go编译器是会告诉你无法找到add_xxx函数.
   小写字母开头的函数只在本炮内可见,大写字母开头的函数才能被其他包使用.
   ```
   1.不定参数
    ```
     - 不定参数
        func myfunc(args ...int) {
            for _, arg := range arge {
                fmt.Println(arg)
            }
        }
        形如 ...type格式的类型只能作为函数的参数类型存在并且必须是最后一个参数.它是一个语法唐.从本质实现机理来说,类型 ...type本质是一个数组切片.也就是[]type.
     - 不定参数的传递
        func myfunc(arge ...int) {
            myfunc(args...) //按原样传递
            
            myfunc(arge[1:]...)     // 传递片段
        }
     - 任意类型的不定参数
        func Pringf(format string, args ...interface{}) {
            // ...
        }
        用interface{}传递任意类型数据是Go语言的惯例用法.使用interface{}仍然是类型安全的.
   ```
   1. 多返回值
    ```
    Go语言的函数或者成员的方法可以有多个返回值,这个特性能够写出比其他语言更优雅,更简洁的代码.
        func(file **File) Read(b []byte) (n int, err error)
        返回值被命名之后,它们的值在函数开始的时候被自动初始化为空,在函数中执行不带任何参数的return语句时,会返回对应的返回值变量的值.
        Go语言并不需要强制命名返回值,但是命名后的返回值可以让代码更清晰,可读性更强,同时也可以用于文档.
        如果调用方调用了一个具有多返回值的方法,但是却不想关系其中的某个返回值,可以简单地用一个下划线"_"来跳过这个返回值.
   ```
   1. 匿名函数与闭包
    ```
    匿名函数是指不需要定义函数的一种函数实现方式,他并不是一个新概念,最早可以回溯到1958年Lisp语言.
        - 匿名函数
            在Go里面, 函数可以像普通函数一样被传递或使用,这与C语言的回调函数比较类似.不同的是,Go语言支持随时在代码里定义匿名函数.
            匿名函数由一个不带函数名的函数声明和函数体组成.
                func(a, b int, z float64) bool {
                    return a * b < int(z)
                }
            匿名函数可以直接赋值给一个变量或者直接执行.
                f := func(x, u int) int {
                    return x + y
                }
        
                func(ch chan int) {
                    ch <- ACK
                }(reply_chan) // 花括号后直接跟参数列表表示函数调用
        - 闭包
            Go的匿名函数是一个闭包.
            基本概念
                闭包是可以包含自由(为绑定到特定对象)变量的代码块,这些变量不再这个代码块内或者任何全局函数上下文中定义,而是在定义代码块的环境中定义.要执行的代码块为自由变量提供绑定的计算环境.
            闭包的价值
                闭包的价值在于可以作为函数对象或者匿名函数,对于类型系统而言,这意味着不仅要表示数据还要表示代码.支持闭包的多数语言都建函数作为第一级对象,就是说这些函数可以存储到变量中作为参数传递给其他函数,最重要的是能够被函数动态创建和返回.
            Go语言中的闭包
                Go语言中的闭包同样也会引用到函数外的变量.闭包的实现确保只要闭包汉被使用,那么被闭包引用的变量会一直存在.           
   ```
1. 错误处理
    ```
    错误处理是学习任何编成语言都需要考虑的一个重要话题.
   ```
   1. error接口
        ```
        Go语言引入了一个关于错误处理的标准模式,即error接口
            tyoe error interface {
                Error() string
            }
      ```
   1. defer
        ```
        延迟调用
            defer func() {
            }()
      
            defer dstFile.Close()
            一个函数中可以存在多个defer语句需要注意的是,defer语句的调用是遵照先进后出的原则.最后一个defer语句将最后被执行.
            return, panic()之后的defer不会执行
      ```
   1. panic() 和 recover()
        ```
        Go语言引入了两个内置函数panic()和recover()以报告和处理运行时错误和程序中的错误场景.
            func painc(interface{})
            func recover() interface{}
        当在一个函数执行过程中调用panic()函数时,正常的函数执行流程将立即终止,但函数中之前使用defer关键字延迟执行的语句将正常展开执行,之后该函数将返回到调用函数,
        并导致琢层向上执行panic流程,直至所属的goroutine中所有正在执行的函数被终止.错误信息将被报告,包括在调用panic()函数时传入的参数,这个过程称为错误处理流程.
        recover()函数用于终止错误处理流程.一般情况下,recover()应该在一个使用defer关键字的函数中被执行以有效截取错误处理流程.如果没有在发生异常的goroutine中
      明确调用恢复过程(使用recover关键字),会导致该goroutine所属的进程打印异常信息后直接退出.
      ```
      